using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace DungeonGenerator
{
    /*
    public class BoardManager : MonoBehaviour
    {
        //List<Tile> DoorList;
        Cell[] FloorMap;
        public float tileOffset;
        //public Machine machinePrefab;
        //public Lake lakePrefab;

        //RULES: There is wall at P with X% probability. In next generation there is a wall at spot P if P has at least 5 walls around it.
        //winit(p) = rand(0,100) < probChance
        //R(p) = the number of tiles within n step of p which are walls
        //W'(p) = R(p) >= 5 || R(p) == 0

        //OTHER RULES: If a wall has less than two walls as neighbors, it is destroyed. Afterward, the map uses a flood fill method to ensure only the largest blob is kept.
        // Each map has a border that is two walls thick. Any walls that have a neighboring floor are 'granite' and have a matching tile. These can be destroyed with explosions, exposing the inner walls.
        // Before placing any special tiles, lakes, or machines all floors are generated.
        // Map elements are then placed in the following order: floors and walls, machines, lakes, ((cleanup)), stairs, chests, monsters, traps, ((instantiation)).

        //MACHINE RULES: A new machine is placed at levels 2-3, 5-6, and 8-9 (three total). Each machine will have a chest with a SKELETON KEY, but it will be guarded by a difficult challenge of some sort.
        // A machine is a special, premade room that is placed somewhere on the edge of the level, replacing the walls and floors located there.
        // Failing to overcome a machine can lead to death or denied the chance to get a SKELETON KEY.

        //LAKE RULES: A new lake is generated by using cellular automata on the floor tiles at a 55% probChance, 5 iterations, and using the rule B5-8/S4-8.
        // Only the blobs that are equal to or higher than the minimum size or equal to or lower than the maximum size are kept.
        // The maximum size for lakes is equal to 1/5th of the map size. A pit space cannot be placed at the same point where a pit space is located above or a floor is not located below. Pits cannot be generated on the 10th level.
        // Edges (tiles with at least 1 floor neighbor) are placed after the lake is generated. Lakes cannot be generated in machines.
        // If a lake affects passability, it will create a bridge through it. 

        //CLEANUP RULES: If the tile is a Floor or Wall, it has at least 4 neighbors that are Lakes, and it is not on the border, it becomes a Lake. If the tile is a Lake and its neighbors directly
        // above, below, left, and right of it are not Lakes, it becomes a Floor. Lastly, Flood Fill for all Floor Tiles.

        //DOOR RULES: The starting doors are placed at an open space in the second open row of tiles closest to the opposite end of the map from the other door. 
        // A floodfill is then done from the starting door, including all tiles except walls and machines. If the fill list is less than 1/3 the map size, then it is converted to walls and a new place for doors is found.
        // A floodfill is done from the starting doors again, this time including all floor tiles only and keep track of distance from the starting doors. The furthest tile becomes the new placement for the doors to the next level.
        // The door to the next floor is placed at a random open space closest to the top of the map, where there is also an open space on the next floor. The list of 'candidates' is chosen from those with
        //      at least 3 Wall neighbors and the longest distance from the entrance to the floor.
        // The door to the previous floor is then placed on that open space.

        //CHEST RULES: There are fifteen chests randomly spread around the dungeon, but only one to two per floor and a higher frequency at lower floors (higher floor numbers). 
        // Chests are always placed in spaces with 4 to 5 walls as neighbors. A random chest on levels 4, 7, and 10 are BIG CHESTS, which require a SKELETON KEY to open.
        // Ten of the chests are filled with GEMS. These can be exchanged for BITS at the merchant. More prized GEMS are found in later levels.

        //MONSTER RULES: There are fourty spawn points placed randomly around the dungeon. Spawn points are always placed in a random space within 3 spaces of each chest.
        // Levels are assigned to the spawns (1-10). Lower levels (1-5) are closer to the earlier levels and higher levels (6-10) are closer to the later levels. 
        // ELITE mobs (spawn with +2 levels) are assigned to BIG CHESTS and DARK CHESTS. Each spawn point will have a random encounter based on the level.

        //TRAP RULES: Each level has anything between 0-1 traps, increasing by +0.25 - +0.5 (rounded down) for each level after the first.

        //BRIDGE RULES: A path is calculated between each of the stairs, ignoring diagonals. Any tile on the path that is a lake is replaced by a bridge tile.

        //BOSS RULES: On the 11th level is a boss. After defeating a boss, they drop a specific level 2 Paw, Trinket, or Outfit and unlock a checkpoint to the next dungeon.

        public void GenerateCell(Cell cell)
        {
            //DoorList = new List<Tile>();
            cell.InitializeTiles();
            cell = RandomFillDungeon(cell);
            cell = SimulateDungeonGrowth(cell);
            //GenerateMachine(machinePrefab, exampleMap);
            GenerateLake(cell.lakePrefab, cell);
            //PlaceDoors(cell);
            //CleanUpDungeon(cell);
            RemoveDiagonals(cell, 10);
            //PlaceBridges(exampleMap);
            //PlaceChests(exampleMap);
            //PlaceMonsters(exampleMap);
            //PlaceTraps(exampleMap);
            //GenerateTileObjects(cell);
            Debug.Log("Cell created!");
        }

        Cell RandomFillDungeon(Cell cell)
        {
            for (int Y = 0; Y < cell.CellLength; Y++)
            {
                for (int X = 0; X < cell.CellWidth; X++)
                {
                    if (cell.TileMap[Y, X].tileType == TileType.Door)
                    {
                        cell.TileMap[Y, X].tileType = TileType.Door;
                    }
                    else if (X == 0)
                    {
                        cell.TileMap[X, Y].tileType = TileType.Wall;
                    }
                    else if (Y == 0)
                    {
                        cell.TileMap[X, Y].tileType = TileType.Wall;
                    }
                    else if (X == cell.CellWidth-1)
                    {
                        cell.TileMap[X, Y].tileType = TileType.Wall;
                    }
                    else if (Y == cell.CellLength-1)
                    {
                        cell.TileMap[X, Y].tileType = TileType.Wall;
                    }
                    else
                    {
                        cell.TileMap[X, Y].tileType = RandomTile(cell.PercentWalls);
                    }
                    
                }
            }

            return cell;
        }

        Cell SimulateDungeonGrowth(Cell oldMap)
        {
            Cell newMap = oldMap;
            //newMap.InitializeTiles();

            for (int i = 0; i < oldMap.SimSteps; i++)
            {
                for(int Y = 1; Y < oldMap.CellLength-1; Y++)
                {
                    for(int X = 1; X < oldMap.CellWidth-1; X++)
                    {
                        int neighbors = countFloorNeighbors(oldMap, X, Y);

                        if (oldMap.TileMap[Y, X].tileType == TileType.Floor)
                        {
                            if (neighbors < oldMap.DeathLimit)
                            {
                                newMap.TileMap[Y, X].tileType = TileType.Wall;
                            }
                            else
                            {
                                newMap.TileMap[Y, X].tileType = TileType.Floor;
                            }
                        }
                        else if (oldMap.TileMap[Y, X].tileType == TileType.Wall)
                        {
                            if (neighbors > oldMap.BirthLimit)
                            {
                                newMap.TileMap[Y, X].tileType = TileType.Floor;
                            }
                            else newMap.TileMap[Y, X].tileType = TileType.Wall;
                        }
                    }
                }
            }

            return newMap;
        }

        int countFloorNeighbors(Cell cell, int x, int y)
        {
            int count = 0;
            for(int i=-1; i<2; i++)
            {
                for (int j=-1; j < 2; j++) {
                    int neigh_x = x + i;
                    int neigh_y = y + j;

                    if (i == 0 && j == 0) { }
                    else if (neigh_x > 0 && neigh_y > 0 && neigh_x < cell.CellWidth-1 && neigh_y < cell.CellLength-1)
                    {
                        if (cell.TileMap[neigh_y, neigh_x].tileType == TileType.Floor)
                        {
                            count++;
                        }
                    }
                    
                }
            }

            return count;
        }

        Cell EmptyMap(Cell cell)
        {
            for (int X = 0, Y = 0; Y < cell.CellLength; Y++)
            {
                for (X = 0; X < cell.CellWidth; X++)
                {
                    cell.TileMap[Y, X].tileType = 0;
                }
            }

            return cell;
        }

        TileType RandomTile(float percent)
        {
            int randomRange = Random.Range(1, 101);
            if (randomRange <= percent)
            {
                return TileType.Wall;
            }
            return TileType.Floor;
        }

        public void PrintMap(Cell cell)
        {
            Debug.Log(MapToString(cell));
        }

        string MapToString(Cell cell)
        {
            string returnString = string.Join(" ", new string[] { "Width:",
                                          cell.CellWidth.ToString(),
                                          "\tHeight:",
                                          cell.CellLength.ToString(),
                                          "\t% Walls:",
                                          cell.PercentWalls.ToString(),
                                          "\t% Cell X/Y:",
                                          cell.OverworldLocationX.ToString() + 
                                          " " + cell.OverworldLocationY.ToString(),
                                          System.Environment.NewLine });

            List<string> mapSymbols = new List<string>();
            mapSymbols.Add("O");
            mapSymbols.Add("#");
            mapSymbols.Add("%");
            mapSymbols.Add("c");
            mapSymbols.Add("D");
            mapSymbols.Add("^");

            for (int Y = 0; Y < cell.CellLength; Y++)
            {
                for (int X = 0; X < cell.CellWidth; X++)
                {
                    returnString += mapSymbols[(int)cell.TileMap[Y, X].tileType];
                }
                returnString += System.Environment.NewLine;
            }
            return returnString;
        }

        void GenerateLake(Lake lake, Cell cell)
        {

            float lakePercent = Random.Range(lake.MaxPercentLake / 2, lake.MaxPercentLake);
            //float lakePercent = lake.MaxPercentLake;

            for (int Y = 3; Y < cell.CellLength-3; Y++)
            {
                for (int X = 3; X < cell.CellWidth-3; X++)
                {
                    if (X > 2 && Y > 2 && X < cell.CellWidth - 2 && Y < cell.CellLength - 2 && cell.TileMap[Y, X].tileType != TileType.Door && cell.TileMap[Y + 1, X].tileType != TileType.Door &&
                        cell.TileMap[Y - 1, X].tileType != TileType.Door && cell.TileMap[Y, X + 1].tileType != TileType.Door && cell.TileMap[Y, X - 1].tileType != TileType.Door)
                        //cell.TileMap[lakeSeedY, lakeSeedX].tileType = TileType.Lake; 
                        cell.TileMap[Y, X].tileType = lake.LakeRandomTile(lakePercent, cell.TileMap[Y, X].tileType);
                }
            }


            int convertcount = 0;
            for (int Y = 3; Y < cell.CellLength-3; Y++)
            {
                for (int X = 3; X < cell.CellWidth-3; X++)
                {
                    for (int s = 0; s < lake.SimSteps; s++)
                    {
                        int neighbors = lake.countLakeNeighbors(cell, X, Y);

                        if (cell.TileMap[Y, X].tileType == TileType.Lake)
                        {
                            //if tile is surrounded by number of Lake cells LESS THAN Death Limit, they die
                            if (neighbors < lake.DeathLimit)
                            {
                                cell.TileMap[Y, X].tileType = TileType.Wall;
                            }
                            else
                            {
                                cell.TileMap[Y, X].tileType = TileType.Lake;
                                convertcount++;
                            }
                        }
                        else
                        {
                            //if tile is surrounded by number of Lake cells MORE THAN Birth Limit, they come alive
                            if (neighbors > lake.BirthLimit)
                            {
                                cell.TileMap[Y, X].tileType = TileType.Lake;
                                convertcount++;
                            }
                            //else cell.TileMap[Y, X].tileType = RandomTile(cell.PercentWalls);
                        }
                    }
                }
            }

            Debug.Log("Conversion Count = " + convertcount++);
        }

        public void PlaceDoors(Cell cell)
        {
            if (cell.DoorList == null) cell.DoorList = new List<Tile>();

            if (cell.Directions != null && cell.Directions.Length == 4)
            {
                if(cell.Directions[0])
                {
                    cell.TileMap[0, cell.CellWidth / 4].tileType = TileType.Door;
                    cell.TileMap[0, (cell.CellWidth / 4) + 1].tileType = TileType.Door;
                    cell.DoorList.Add(cell.TileMap[0, cell.CellWidth / 4]);
                    cell.DoorList.Add(cell.TileMap[0, (cell.CellWidth / 4) + 1]);
                    Debug.Log("Door assigned!");
                }
                if (cell.Directions[1])
                {
                    cell.TileMap[cell.CellLength / 4, 0].tileType = TileType.Door;
                    cell.TileMap[(cell.CellLength / 4) + 1, 0].tileType = TileType.Door;
                    cell.DoorList.Add(cell.TileMap[cell.CellLength / 4, 0]);
                    cell.DoorList.Add(cell.TileMap[(cell.CellLength / 4) + 1, 0]);
                    Debug.Log("Door assigned!");
                }
                if (cell.Directions[2])
                {
                    cell.TileMap[cell.CellLength - 1, cell.CellWidth / 4].tileType = TileType.Door;
                    cell.TileMap[cell.CellLength - 1, (cell.CellWidth / 4) + 1].tileType = TileType.Door;
                    cell.DoorList.Add(cell.TileMap[cell.CellLength - 1, cell.CellWidth / 4]);
                    cell.DoorList.Add(cell.TileMap[cell.CellLength - 1, (cell.CellWidth / 4) + 1]);
                    Debug.Log("Door assigned!");
                }
                if (cell.Directions[3])
                {
                    cell.TileMap[cell.CellLength / 4, cell.CellWidth - 1].tileType = TileType.Door;
                    cell.TileMap[(cell.CellLength / 4) + 1, cell.CellWidth - 1].tileType = TileType.Door;
                    cell.DoorList.Add(cell.TileMap[cell.CellLength / 4, cell.CellWidth - 1]);
                    cell.DoorList.Add(cell.TileMap[(cell.CellLength / 4) + 1, cell.CellWidth - 1]);
                    Debug.Log("Door assigned!");
                }

                ClearPathBetweenDoors(cell);
            }
        }

        void ClearPathBetweenDoors(Cell cell)
        {
            Debug.Log("Clearing path to door!");
            Tile masterDoor = cell.DoorList[Random.Range(0, cell.DoorList.Count - 1)];
            int connectedDoors = 1;

            while(connectedDoors < cell.DoorList.Count)
            foreach (Tile door in cell.DoorList)
            {
                    if (door != masterDoor)
                        if (ExpandToTargetTile(cell, masterDoor, door))
                        {
                            connectedDoors++;
                        }
            }
        }

        void GenerateTileObjects(Cell cell)
        {
            for (int Y = 0; Y < cell.CellLength; Y++)
            {
                for (int X = 0; X < cell.CellWidth; X++)
                {
                    switch (cell.TileMap[Y,X].tileType)
                    {
                        case TileType.Floor:
                            Instantiate(cell.floorPrefab, TileCoordToScene(cell, X, Y), Quaternion.identity, cell.transform).SetActive(false);
                            break;
                        case TileType.Wall:
                            Instantiate(cell.wallPrefab, TileCoordToScene(cell, X, Y), Quaternion.identity, cell.transform).SetActive(false);
                            break;
                        case TileType.Lake:
                            //Instantiate(cell.lakePrefab.MainTilePrefab, TileCoordToScene(cell, X, Y), Quaternion.identity, transform);
                            break;
                        default: break;
                    }
                }
            }

            cell.gameObject.SetActive(false);
        }

        public void CleanUpDungeon(Cell cell)
        {
            for (int Y = 0; Y < cell.CellLength; Y++)
            {
                for (int X = 0; X < cell.CellWidth; X++)
                {
                    if (Y > 1 && Y < cell.CellLength - 2 && X > 1 && X < cell.CellWidth - 2)
                    {
                        
                        for (int steps = 0; steps < 2; steps++)
                        {
                            if (!cell.TileMap[Y, X].isReachable) cell.TileMap[Y, X].tileType = TileType.Wall;

                            //Convert Orphan Floor/Wall Tiles near Lakes; try twice
                            if (cell.TileMap[Y, X].tileType == TileType.Floor || cell.TileMap[Y, X].tileType == TileType.Wall)
                            {
                                int lakeCount = 0;

                                for (int i = -1; i < 2; i++)
                                {
                                    for (int j = -1; j < 2; j++)
                                    {

                                        int neigh_x = cell.TileMap[Y, X].mapLocationX + i;
                                        int neigh_y = cell.TileMap[Y, X].mapLocationY + j;

                                        if (i == 0 && j == 0) { }
                                        else if (neigh_x < 2 || neigh_y < 2 || neigh_x >= cell.CellWidth - 2 || neigh_y >= cell.CellLength - 2) { }
                                        else if (cell.TileMap[neigh_y, neigh_x].tileType == TileType.Lake)
                                        {
                                            lakeCount++;
                                        }
                                    }
                                }

                                if (lakeCount > 1) cell.TileMap[Y, X].tileType = TileType.Lake;
                            }

                        }

                        // Convert Orphan Lake Tiles
                        for (int steps = 0; steps < 2; steps++)
                        {
                            
                            if (cell.TileMap[Y, X].tileType == TileType.Lake)
                            {
                                int floorwallCount = 0;

                                for (int i = -1; i < 2; i++)
                                {
                                    for (int j = -1; j < 2; j++)
                                    {

                                        int neigh_x = cell.TileMap[Y, X].mapLocationX + i;
                                        int neigh_y = cell.TileMap[Y, X].mapLocationY + j;

                                        if (i == 0 && j == 0) { }   //(i != 0 || j != 0) ||
                                        else if (neigh_x < 2 || neigh_y < 2 || neigh_x >= cell.CellWidth - 2 || neigh_y >= cell.CellLength - 2) { }
                                        else if (cell.TileMap[neigh_y, neigh_x].tileType == TileType.Floor || cell.TileMap[neigh_y, neigh_x].tileType == TileType.Wall)
                                        {
                                            floorwallCount++;
                                        }
                                    }
                                }

                                if (floorwallCount > 5) cell.TileMap[Y, X].tileType = TileType.Floor;
                            }
                        }
                    }

                }
            }
            
        }

        void FloodFillDungeon(Cell cell, Tile tileToFill)
        {
            if(!tileToFill.isReachable && (tileToFill.tileType == TileType.Floor || tileToFill.tileType == TileType.Door)) tileToFill.isReachable = true;

            if(tileToFill.isReachable)
            {
                if ((tileToFill.mapLocationX - 1) > 1 &&
                !cell.TileMap[tileToFill.mapLocationY, tileToFill.mapLocationX - 1].isReachable) FloodFillDungeon(cell, cell.TileMap[tileToFill.mapLocationY, tileToFill.mapLocationX - 1]);
                if ((tileToFill.mapLocationX + 1) < cell.CellWidth-1 &&
                    !cell.TileMap[tileToFill.mapLocationY, tileToFill.mapLocationX + 1].isReachable) FloodFillDungeon(cell, cell.TileMap[tileToFill.mapLocationY, tileToFill.mapLocationX + 1]);
                if ((tileToFill.mapLocationY - 1) > 1 &&
                    !cell.TileMap[tileToFill.mapLocationY - 1, tileToFill.mapLocationX].isReachable) FloodFillDungeon(cell, cell.TileMap[tileToFill.mapLocationY - 1, tileToFill.mapLocationX]);
                if ((tileToFill.mapLocationY + 1) < cell.CellLength-1 &&
                    !cell.TileMap[tileToFill.mapLocationY + 1, tileToFill.mapLocationX].isReachable) FloodFillDungeon(cell, cell.TileMap[tileToFill.mapLocationY + 1, tileToFill.mapLocationX]);
            }

            /*
            List<Tile> FloodFill = new List<Tile>();
            FloodFill.Add(startingTile);

            while (FloodFill.Count > 0)
            {
                Tile n = FloodFill[FloodFill.Count - 1];
                FloodFill.RemoveAt(FloodFill.Count-1);

                if(n.mapLocationX > 0 && n.mapLocationX < cell.CellWidth && n.mapLocationY > 0 && n.mapLocationY < cell.CellLength)
                {
                    if(cell.TileMap[n.mapLocationY, n.mapLocationX].tileType == TileType.Floor 
                        || cell.TileMap[n.mapLocationY, n.mapLocationX].tileType == TileType.Door)
                    {
                        cell.TileMap[n.mapLocationY, n.mapLocationX].isReachable = true;
                        if ((n.mapLocationX - 1) > 0) FloodFill.Add(cell.TileMap[n.mapLocationY, n.mapLocationX - 1]);
                        if((n.mapLocationX + 1) < cell.CellWidth) FloodFill.Add(cell.TileMap[n.mapLocationY, n.mapLocationX + 1]);
                        if((n.mapLocationY - 1) > 0) FloodFill.Add(cell.TileMap[n.mapLocationY - 1, n.mapLocationX]);
                        if((n.mapLocationY + 1) < cell.CellLength) FloodFill.Add(cell.TileMap[n.mapLocationY + 1, n.mapLocationX]);
                    }
                }
            }*/

    //FloodFill.Clear(); 
    /*
    for (int Y = 0; Y < cell.CellLength; Y++)
    {
        for (int X = 0; X < cell.CellWidth; X++)
        {
            if (cell.TileMap[Y, X].isReachable == false) cell.TileMap[Y, X].tileType = TileType.Wall;
        }
    }
}

void RemoveDiagonals(Cell cell, int steps)
{

    //Check for diagonals and convert walls to floors
    for (int s = 0; s < steps; s++)
    {
        for (int Y = 0; Y < cell.CellLength; Y++)
        {
            for (int X = 0; X < cell.CellWidth; X++)
            {
                if (cell.TileMap[Y, X].tileType == TileType.Floor)
                {
                    if ((Y + 1) < cell.CellLength && (X + 1) < cell.CellWidth)
                    {
                        if (cell.TileMap[Y + 1, X].tileType == TileType.Wall && cell.TileMap[Y, X + 1].tileType == TileType.Wall
                            && cell.TileMap[Y + 1, X + 1].tileType == TileType.Floor)
                        {
                            cell.TileMap[Y + 1, X].tileType = TileType.Floor;
                            cell.TileMap[Y, X + 1].tileType = TileType.Floor;
                        }
                    }
                }

                if (cell.TileMap[Y, X].tileType == TileType.Wall)
                {
                    if ((Y + 1) < cell.CellLength && (X + 1) < cell.CellWidth)
                    {
                        if (cell.TileMap[Y + 1, X].tileType == TileType.Floor && cell.TileMap[Y, X + 1].tileType == TileType.Floor
                            && cell.TileMap[Y + 1, X + 1].tileType == TileType.Wall)
                        {
                            cell.TileMap[Y, X].tileType = TileType.Floor;
                            cell.TileMap[Y + 1, X + 1].tileType = TileType.Floor;
                        }
                    }
                }
            }
        }
    }

    //Convert orphan walls into floors
    for (int Y = 0; Y < cell.CellLength; Y++)
    {
        for (int X = 0; X < cell.CellWidth; X++)
        {
            if (cell.TileMap[Y, X].tileType == TileType.Wall && countFloorNeighbors(cell, X, Y) > 5)
            {
                cell.TileMap[Y, X].tileType = TileType.Floor;
            }
        }
    }
}

bool ExpandToTargetTile(Cell cell, Tile origin, Tile destination)
{
    Debug.Log("Expanding to target tile.");
    List<Tile> DiscoveredSet = new List<Tile>();
    List<Tile> FrontierSet = new List<Tile>();

    //perform breadth first search; if frontier set equals coordinates of door return true; if search is exhausted return false
    //find frontier tile closest to door and convert nearby wall tiles to floor tiles
    DiscoveredSet.Add(origin);
    FrontierSet.Add(origin);
    origin.isReachable = true;
    while (FrontierSet.Count > 0)
    {
        for(int t = 0; t < FrontierSet.Count - 1; t++)
        {
            Tile currentTile = FrontierSet[t];
            FrontierSet.RemoveAt(t);

            for (int i = -1; i < 2; i++)
            {
                for (int j = -1; j < 2; j++)
                {
                    int neigh_x = currentTile.mapLocationX + i;
                    int neigh_y = currentTile.mapLocationY + j;

                    if (i == 0 && j == 0) { }
                    else if (neigh_x > 0 && neigh_y > 0 && neigh_x < cell.CellWidth - 1 && neigh_y < cell.CellLength - 1)
                    {
                        if (cell.TileMap[neigh_y, neigh_x] == destination)
                        {
                            Debug.Log("Cell found!");
                            return true;
                        }
                        else if (cell.TileMap[neigh_y, neigh_x].tileType == TileType.Floor || cell.TileMap[neigh_y, neigh_x].tileType == TileType.Lake)
                        {
                            FrontierSet.Add(cell.TileMap[neigh_y, neigh_x]);
                            DiscoveredSet.Add(cell.TileMap[neigh_y, neigh_x]);
                            cell.TileMap[neigh_y, neigh_x].isReachable = true;
                        }
                    }

                }
            }
        }

        if(FrontierSet.Count < 1)
        {
            float closestDistance = CalculateDistance(cell.CellWidth, cell.CellLength, 0, 0);
            Tile closestTile = null;

            for (int t = 0; t < DiscoveredSet.Count - 1; t++)
            {
                if(closestTile.tileType == TileType.Floor)
                    if (CalculateDistance(DiscoveredSet[t].mapLocationX, DiscoveredSet[t].mapLocationY, destination.mapLocationX, destination.mapLocationY) < closestDistance)
                    {
                        closestDistance = CalculateDistance(DiscoveredSet[t].mapLocationX, DiscoveredSet[t].mapLocationY, destination.mapLocationX, destination.mapLocationY);
                        closestTile = DiscoveredSet[t];
                    }
            }

            if (closestTile != null)
            {
                ConvertAdjacentTiles(cell, closestTile.mapLocationX, closestTile.mapLocationY, TileType.Wall, TileType.Floor);
                FrontierSet.Add(closestTile);
            }
            else return false;
        }
    }

    return false;
}

void ConvertAdjacentTiles(Cell cell, int x, int y, TileType oldType, TileType newType)
{
    for (int i = -1; i < 2; i++)
    {
        for (int j = -1; j < 2; j++)
        {
            int neigh_x = x + i;
            int neigh_y = y + j;

            if (i == 0 && j == 0) { }
            else if (neigh_x > 0 && neigh_y > 0 && neigh_x < cell.CellWidth - 1 && neigh_y < cell.CellLength - 1)
            {
                if (cell.TileMap[neigh_y, neigh_x].tileType == oldType)
                {
                    cell.TileMap[neigh_y, neigh_x].tileType = newType;
                }
            }

        }
    }
}

/*void PlaceDoorsRandom(Cell cell)
{
    List<Tile> DoorCandidateList = new List<Tile>();

    //1. find coordinate of adjacent cell's door
    //2. place door at adjacent cell's door
    //3. if no adjacent cell exists, do not place door at that edge
    //4. if adjacent cell exists and adjacent cell does not have a door, place a door at random point on edge
    //4. apply special rules for doors depending on CellType

    //gather all stair candidates in a list, ensure they follow rules for stair placement, then pick randomly

    for(int checkY = 0, checkX = 0; checkY < cell.CellLength; checkY++)
    {
        for(checkX = 0; checkX < cell.CellWidth; checkX++)
        {
            if ((checkX > 0 || checkX < cell.CellWidth - 1) && checkY == 0) DoorCandidateList.Add(cell.TileMap[checkY, checkX]);
            else if ((checkX > 0 || checkX < cell.CellWidth - 1) && checkY == cell.CellLength) DoorCandidateList.Add(cell.TileMap[checkY, checkX]);
            else if ((checkY > 0 || checkY < cell.CellLength - 1) && checkX == 0) DoorCandidateList.Add(cell.TileMap[checkY, checkX]);
            else if ((checkY > 0 || checkY < cell.CellLength - 1) && checkX == cell.CellWidth) DoorCandidateList.Add(cell.TileMap[checkY, checkX]);
        }
    }

    if(DoorCandidateList.Count > 0)
    {
        int randomDoor = Random.Range(0, DoorCandidateList.Count - 1);
        int doorX = DoorCandidateList[randomDoor].mapLocationX;
        int doorY = DoorCandidateList[randomDoor].mapLocationY;
        Debug.Log("Tile chosen is a " + cell.TileMap[doorY, doorX].tileType);
        cell.TileMap[doorY, doorX].tileType = TileType.Door;
        DoorList.Add(cell.TileMap[doorY, doorX]);

        if ((doorX > 0 | doorX < cell.CellWidth - 1) & doorY == 0) cell.TileMap[doorY+1, doorX].tileType = TileType.Floor;
        else if ((doorX > 0 | doorX < cell.CellWidth - 1) & doorY == cell.CellLength) cell.TileMap[doorY - 1, doorX].tileType = TileType.Floor;
        else if ((doorY > 0 | doorY < cell.CellLength - 1) & doorX == 0) cell.TileMap[doorY, doorX + 1].tileType = TileType.Floor;
        else if ((doorY > 0 | doorY < cell.CellLength - 1) & doorX == cell.CellWidth) cell.TileMap[doorY, doorX - 1].tileType = TileType.Floor;
    }
}*/

    /*void GenerateMachine(Machine mach, Dungeon dgn)
{
    int randomTileX, randomTileY;
    randomTileX = Random.Range(2, dgn.MapWidth - mach.MachineWidth);
    randomTileY = Random.Range(2, dgn.MapLength - mach.MachineLength);

    for (int i = 0; i < mach.MachineLength; i++)
    {
        for (int j = 0; j < mach.MachineWidth; j++)
        {
            dgn.TileMap[randomTileY+i, randomTileX+j].tileType = TileType.Machine;
        }
    }
}*/
/*
    Vector3 TileCoordToScene(Cell cell, int X, int Y)
        {
            return new Vector3(cell.transform.position.x + (X * tileOffset), 0, cell.transform.position.z + (Y * tileOffset));
        }

        float CalculateDistance(int X1, int Y1, int X2, int Y2)
        {
            return Mathf.Sqrt(Mathf.Pow(X2 - X1, 2) + Mathf.Pow(Y2 - Y1, 2));
        }
    }*/
}

